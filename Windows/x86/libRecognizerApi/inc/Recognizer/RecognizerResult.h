/**
 * @file RecognizerResult.h
 *
 * Copyright (c)2015 MicroBlink Ltd. All rights reserved.
 *
 * ANY UNAUTHORIZED USE OR SALE, DUPLICATION, OR DISTRIBUTION
 * OF THIS PROGRAM OR ANY OF ITS PARTS, IN SOURCE OR BINARY FORMS,
 * WITH OR WITHOUT MODIFICATION, WITH THE PURPOSE OF ACQUIRING
 * UNLAWFUL MATERIAL OR ANY OTHER BENEFIT IS PROHIBITED!
 * THIS PROGRAM IS PROTECTED BY COPYRIGHT LAWS AND YOU MAY NOT
 * REVERSE ENGINEER, DECOMPILE, OR DISASSEMBLE IT.
 */

#ifndef RECOGNIZERRESULT_H_
#define RECOGNIZERRESULT_H_

#include <stdlib.h>

#include "RecognizerError.h"
#include "Export.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 @struct RecognizerResult
 @brief RecognizerResult data structure. Holds the results of the recognition.
 
 You can use various getter methods to obtain results of the recognition or to inspect the type of recognizer result.
 */
typedef PP_EXPORTED_TYPE struct RecognizerResult RecognizerResult;

/**
 * @memberof RecognizerResult
 * @brief Obtain whether given recognizer result is empty.
 * Example:
 * @code
 *      RecognizerResult *result;
 *      int empty;
 *      RecognizerErrorStatus status = recognizerResultIsResultEmpty(recognizer, &empty);
 *      if(empty) {
 *          // handle empty data
 *      } else {
 *          // handle non-empty data
 *      }
 * @endcode
 *
 * @param   result          RecognizerResult object which stores the values of the results.
 * @param   empty           Pointer to an integer where result of operation will be stored.
 * @return  errorStatus     Status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK,
 *                              RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter
 *
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsResultEmpty(const RecognizerResult* result, int* empty);

/**
* @memberof RecognizerResult
* @brief Obtain whether given recognizer result is valid.
* Example:
* @code
*      RecognizerResult *result;
*      int valid;
*      RecognizerErrorStatus status = recognizerResultIsResultValid(recognizer, &valid);
*      if(valid) {
*          // handle valid data
*      } else {
*          // handle invalid data
*      }
* @endcode
*
* @param result RecognizerResult object which stores the values of the results.
* @param valid Pointer to an integer where result of operation will be stored.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter
*
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsResultValid(const RecognizerResult* result, int* valid);


/**
* @memberof RecognizerResult
* @brief Returns non-zero value if given result is generated by Machine Readable Travel Document recognizer.
* @param result RecognizerResult object
* @param isMrtd pointer to store result of the operation: non-zero if given object is generated by MRTD recognizer, zero otherwise.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsMRTDResult(const RecognizerResult* result, int* isMrtd);

/**
* @memberof RecognizerResult
* @brief Returns the document code string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param documentCode Pointer to char pointer that will be set to document code string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDDocumentCode(const RecognizerResult* result, const char** documentCode);

/**
* @memberof RecognizerResult
* @brief Returns the issuer string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param issuer Pointer to char pointer that will be set to issuer string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDIssuer(const RecognizerResult* result, const char** issuer);

/**
* @memberof RecognizerResult
* @brief Returns the document number string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param documentNumber Pointer to char pointer that will be set to document number string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDDocumentNumber(const RecognizerResult* result, const char** documentNumber);

/**
* @memberof RecognizerResult
* @brief Returns the opt1 string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param opt1 Pointer to char pointer that will be set to opt1 string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDOpt1(const RecognizerResult* result, const char** opt1);

/**
* @memberof RecognizerResult
* @brief Returns the date of birth string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param dateOfBirth Pointer to char pointer that will be set to date of birth string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDDateOfBirth(const RecognizerResult* result, const char** dateOfBirth);

/**
* @memberof RecognizerResult
* @brief Returns the sex string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param sex Pointer to char pointer that will be set to sex string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDSex(const RecognizerResult* result, const char** sex);

/**
* @memberof RecognizerResult
* @brief Returns the date of expiry string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param dateOfExpiry Pointer to char pointer that will be set to date of expiry string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDDateOfExpiry(const RecognizerResult* result, const char** dateOfExpiry);

/**
* @memberof RecognizerResult
* @brief Returns the nationality string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param nationality Pointer to char pointer that will be set to nationality string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDNationality(const RecognizerResult* result, const char** nationality);

/**
* @memberof RecognizerResult
* @brief Returns the opt2 string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param opt2 Pointer to char pointer that will be set to opt2 string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDOpt2(const RecognizerResult* result, const char** opt2);

/**
* @memberof RecognizerResult
* @brief Returns the primary ID string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param primaryID Pointer to char pointer that will be set to primary ID string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDPrimaryID(const RecognizerResult* result, const char** primaryID);

/**
* @memberof RecognizerResult
* @brief Returns the secondary ID string from MRTD result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param secondaryID Pointer to char pointer that will be set to secondary ID string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDSecondaryID(const RecognizerResult* result, const char** secondaryID);

/**
 * @memberof RecognizerResult
 * @brief Returns the alien number from Machine Readable Zone of Green Cards.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * @param result RecognizerResult object which stores the values of the results
 * @param alienNumber Pointer to char pointer that will be set to alien number string or NULL if alien number does not exist (i.e. Green Card was not scanned).
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDAlienNumber(const RecognizerResult* result, const char** alienNumber);

/**
 * @memberof RecognizerResult
 * @brief Returns the application receipt number from Machine Readable Zone of Green Cards.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * @param result RecognizerResult object which stores the values of the results
 * @param applicationReceiptNumber Pointer to char pointer that will be set to application receipt number string or NULL if application receipt number does not exist (i.e. Green Card was not scanned).
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDApplicationReceiptNumber(const RecognizerResult* result, const char** applicationReceiptNumber);

/**
 * @memberof RecognizerResult
 * @brief Returns the immigrant case number from Machine Readable Zone of Green Cards.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * @param result RecognizerResult object which stores the values of the results
 * @param immigrantCaseNumber Pointer to char pointer that will be set to immigrant case number string or NULL if immigrant case number does not exist (i.e. Green Card was not scanned).
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MRTD result.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDImmigrantCaseNumber(const RecognizerResult* result, const char** immigrantCaseNumber);

/**
 * @enum MRTDDocumentType
 * Possible types of Machine Readable Travel Documents.
 */
typedef PP_EXPORTED_TYPE enum _mrtd_document_type_t {
    /** Represents unknown MRTD document */
    MRTD_TYPE_UNKNOWN,
    /** Represents Identity card */
    MRTD_TYPE_IDENITY_CARD,
    /** Represents passport */
    MRTD_TYPE_PASSPORT,
    /** Represents visa */
    MRTD_TYPE_VISA,
    /** Represents green card */
    MRTD_TYPE_GREEN_CARD
} MRTDDocumentType;

/**
 * @memberof MRTDDocumentType
 * @brief Returns a string representation of MRTDDocumentType enum. Returned pointer is a string constant.
 * @param mrtd MRTDDocumentType value.
 * @return String representation of mrtd.
 */
PP_API const char* PP_CALL mrtdDocumentTypeToString(MRTDDocumentType mrtd);

/**
 * @memberof RecognizerResult
 * @brief Returns the type of Machine Readable Document that was scanned.
 * @param result RecognizerResult object.
 * @param mrtdType pointer to MRTDDocumentType enum that will be set to type of Machine Readable Document scanned.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result
 *         is not generated by MRTD scanning, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDDocumentType(const RecognizerResult* result, MRTDDocumentType* mrtdType);

/**
* @memberof RecognizerResult
* @brief Obtains the raw string representation of data from Machine Readable Travel Document.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* Example:
* @code
const char* res;
RecognizerErrorStatus status = recognizerResultGetMRTDRawStringData(result, &res);

if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
// use the value res
} else {
const char* statusString = recognizerErrorToString(status);
printf("Error status: %s\n", statusString);

// handle error
}
* @endcode
*
* @param result RecognizerResult object which stores the values of the results
* @param dst Pointer to char pointer that will be set to internal array holding the string data.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not generated by MRTD recognizer.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMRTDRawStringData(const RecognizerResult* result, const char** dst);





/**
 * @memberof RecognizerResult
 * @brief Returns non-zero value if given result is generated by PDF417 recognizer.
 * @param result RecognizerResult object
 * @param isPdf417 pointer to store result of the operation: non-zero if given object is generated by PDF417 recognizer, zero otherwise.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsPdf417Result(const RecognizerResult* result, int* isPdf417);



/**
 * @memberof RecognizerResult
 * @brief Returns non-zero value if given result is generated by 1D barcode recognizer (Microblink's implementation).
 * @param result RecognizerResult object
 * @param isBardecoder pointer to store result of the operation: non-zero if given object is generated by 1D barcode recognizer (Microblink's implementation), zero otherwise.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsBardecoderResult(const RecognizerResult* result, int* isBardecoder);



/**
 * @memberof RecognizerResult
 * @brief Returns non-zero value if given result is generated by ZXing recognizer.
 * @param result RecognizerResult object
 * @param isZXing pointer to store result of the operation: non-zero if given object is generated by ZXing recognizer, zero otherwise.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsZXingResult(const RecognizerResult* result, int* isZXing);



/**
 * @enum BarcodeType
 * Possible types of barcodes.
 */
typedef PP_EXPORTED_TYPE enum _barcode_type_t {
    /** Represents Aztec 2D barcode */
    BARCODE_TYPE_AZTEC,
    /** Represents Code 128 1D barcode */
    BARCODE_TYPE_CODE128,
    /** Represents Code 39 1D barcode */
    BARCODE_TYPE_CODE39,
    /** Represents DataMatrix 2D barcode */
    BARCODE_TYPE_DATA_MATRIX,
    /** Represents EAN 13 1D barcode */
    BARCODE_TYPE_EAN13,
    /** Represents EAN 8 1D barcode */
    BARCODE_TYPE_EAN8,
    /** Represents ITF 1D barcode */
    BARCODE_TYPE_ITF,
    /** Represents QR code */
    BARCODE_TYPE_QR,
    /** Represents UPC A 1D barcode */
    BARCODE_TYPE_UPCA,
    /** Represents UPC E 1D barcode */
    BARCODE_TYPE_UPCE,
    /** Represents PDF417 2D barcode */
    BARCODE_TYPE_PDF417,
    /** This is returned when result is not a barcode */
    BARCODE_TYPE_NOT_BARCODE
} BarcodeType;

/**
 * @memberof BarcodeType
 * @brief Returns a string representation of BarcodeType enum. Returned pointer is a string constant.
 * @param bt BarcodeType value.
 * @return String representation of bt.
 */
PP_API const char* PP_CALL barcodeTypeToString(BarcodeType bt);

/**
 * @memberof RecognizerResult
 * @brief Returns the type of barcode that was scanned.
 * @param result RecognizerResult object.
 * @param barcodeType pointer to BarcodeType enum that will be set to type of barcode scanned.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result
 *         is not generated by barcode scanning, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetBarcodeType(const RecognizerResult* result, BarcodeType* barcodeType);

/**
 * @memberof RecognizerResult
 * @brief Obtains the string representation of data inside barcode result.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * NOTE: Method does not work with results generated by US Driver's License recognizer (RECOGNIZER_ERROR_STATUS_INVALID_TYPE is returned). To
 * obtain raw USDL string data, use ::recognizerResultGetUSDLRawStringData
 * Example:
 * @code
    const char* res;
    RecognizerErrorStatus status = recognizerResultGetBarcodeStringData(result, &res);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the value res
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 * @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to char pointer that will be set to internal array holding the string data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a barcode result.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetBarcodeStringData(const RecognizerResult* result, const char** dst);

/**
 * @memberof RecognizerResult
 * @brief Obtains the raw binary barcode data.
 *
 * You can use the obtained byte array until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the byte array later, you must copy it.
 *
 * NOTE: Method does not work with results generated by US Driver's License recognizer (RECOGNIZER_ERROR_STATUS_INVALID_TYPE is returned). To
 * obtain raw USDL string data, use ::recognizerResultGetUSDLRawBinaryData
 *
 * Example:
 *  @code
    const void* barcodeBytes;
    size_t barcodeBytesSize;
    RecognizerErrorStatus status = recognizerResultGetBarcodeRawData(result, &barcodeBytes, &barcodeBytesSize);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the barcodeBytes
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 *  @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to pointer that will be set to point to internal array holding the barcode data.
 * @param size Size of the binary data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a barcode result.
 *
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetBarcodeRawData(RecognizerResult* result, const void** dst, size_t* size);

/**
 * @memberof RecognizerResult
 * @brief Obtains whether given recognizer result is uncertain.
 * Example:
 * @code
 *      RecognizerResult *result;
 *      int uncertain;
 *      RecognizerErrorStatus status = recognizerResultIsResultUncertain(recognizer, &uncertain);
 *      if(status == RECOGNIZER_ERROR_STATUS_SUCCESS && uncertain) {
 *          // handle uncertain data
 *      } else {
 *          // handle certain data
 *      }
 * @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param uncertain Pointer to an integer where result of operation will be stored.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result does not contain that information
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsResultUncertain(const RecognizerResult* result, int *uncertain);

/**
 * @memberof RecognizerResult
 * @brief Obtains the string representation of extended data inside barcode result.  Extended data is supported only in some barcode types (e.g. Code39).
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * Example:
 * @code
    const char* res;
    RecognizerErrorStatus status = recognizerResultGetBarcodeExtendedStringData(result, &res);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the value res
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 * @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to char pointer that will be set to internal array holding the string data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a barcode result or barcode does not support extended data mode.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetBarcodeExtendedStringData(const RecognizerResult* result, const char** dst);

/**
 * @memberof RecognizerResult
 * @brief Obtains the raw binary extended barcode data. Extended data is supported only in some barcode types (e.g. Code39).
 *
 * You can use the obtained byte array until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the byte array later, you must copy it.
 * Example:
 *  @code
    const void* barcodeBytes;
    size_t barcodeBytesSize;
    RecognizerErrorStatus status = recognizerResultGetBarcodeExtendedRawData(result, &barcodeBytes, &barcodeBytesSize);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the barcodeBytes
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 *  @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to pointer that will be set to point to internal array holding the barcode data.
 * @param size Size of the binary data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a barcode result or barcode does not support extended data mode.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetBarcodeExtendedRawData(RecognizerResult* result, const void** dst, size_t* size);



/**
* @memberof RecognizerResult
* @brief Returns non-zero value if given result is generated by Malaysian ID card recognizer.
* @param result RecognizerResult object
* @param isMyKad pointer to store result of the operation: non-zero if given object is generated by MyKad recognizer, zero otherwise.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsMyKadResult(const RecognizerResult* result, int* isMyKad);

/**
* @memberof RecognizerResult
* @brief Returns the owner full name string from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param fullName Pointer to char pointer that will be set to owner full name string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadFullName(const RecognizerResult* result, const char** fullName);

/**
* @memberof RecognizerResult
* @brief Returns the owner address string from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param address Pointer to char pointer that will be set to owner address string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadAddress(const RecognizerResult* result, const char** address);

/**
* @memberof RecognizerResult
* @brief Returns the owner religion string from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param religion Pointer to char pointer that will be set to owner religion string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadReligion(const RecognizerResult* result, const char** religion);

/**
* @memberof RecognizerResult
* @brief Returns the owner sex string from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param sex Pointer to char pointer that will be set to owner sex string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadSex(const RecognizerResult* result, const char** sex);

/**
* @memberof RecognizerResult
* @brief Returns the owner birth date string from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param birthDate Pointer to char pointer that will be set to owner birth date string.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadBirthDate(const RecognizerResult* result, const char** birthDate);

/**
* @memberof RecognizerResult
* @brief Returns the NRIC number from MyKad result.
* You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
* If you want to use the string later, you must copy it.
* String is guaranteed to be zero-terminated.
* @param result RecognizerResult object which stores the values of the results
* @param nricNumber Pointer to char pointer that will be set to NRIC number.
* @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
*         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not a MyKad result.
*/
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetMyKadNricNumber(const RecognizerResult* result, const char** nricNumber);




/**
 * @memberof RecognizerResult
 * @brief Returns non-zero value if given result is generated by US Driver's License recognizer.
 * @param result RecognizerResult object
 * @param isUsdl pointer to store result of the operation: non-zero if given object is generated by US Driver's license recognizer, zero otherwise.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter, RECOGNIZER_ERROR_STATUS_SUCCESS otherwise
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultIsUSDLResult(const RecognizerResult* result, int* isUsdl);

/**
 * @memberof RecognizerResult
 * @brief Obtains the raw string representation of data inside US Driver's license barcode.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * Example:
 * @code
    const char* res;
    RecognizerErrorStatus status = recognizerResultGetUSDLRawStringData(result, &res);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the value res
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 * @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to char pointer that will be set to internal array holding the string data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not generated by US Driver's license recognizer.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetUSDLRawStringData(const RecognizerResult* result, const char** dst);

/**
 * @memberof RecognizerResult
 * @brief Obtains the raw binary data inside US Driver's license barcode.
 *
 * You can use the obtained byte array until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the byte array later, you must copy it.
 * Example:
 *  @code
    const void* barcodeBytes;
    size_t barcodeBytesSize;
    RecognizerErrorStatus status = recognizerResultGetUSDLRawBinaryData(result, &barcodeBytes, &barcodeBytesSize);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the barcodeBytes
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 *  @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to pointer that will be set to point to internal array holding the barcode data.
 * @param size Size of the binary data.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if result is not generated by US Driver's license recognizer.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetUSDLRawBinaryData(RecognizerResult* result, const void** dst, size_t* size);

/**
 * @memberof RecognizerResult
 * @brief Obtains the field inside US Driver's Licence.
 * You can use the obtained string until recognizerResultDelete is called on the RecognizerResult object.
 * If you want to use the string later, you must copy it.
 * String is guaranteed to be zero-terminated.
 * Example:
 * @code
    const char* res;
    RecognizerErrorStatus status = recognizerResultGetUSDLField(result, &res, USDLFieldKeys.kCustomerFirstName);

    if (status == RECOGNIZER_ERROR_STATUS_SUCCESS) {
        // use the value res
    } else {
        const char* statusString = recognizerErrorToString(status);
        printf("Error status: %s\n", statusString);

        // handle error
    }
 * @endcode
 *
 * @param result RecognizerResult object which stores the values of the results
 * @param dst Pointer to char pointer that will be set to internal array holding the string data.
 * @param fieldKey ID of the field to be obtained. Available keys are found in USDLFieldKeys structure.
 * @return status of the operation: RECOGNIZER_ERROR_STATUS_SUCCESS if everything is OK, RECOGNIZER_ERROR_STATUS_POINTER_IS_NULL if NULL is given as parameter,
 *         RECOGNIZER_ERROR_STATUS_INVALID_TYPE if field with given fieldId does not exist.
 */
PP_API RecognizerErrorStatus PP_CALL recognizerResultGetUSDLField(const RecognizerResult* result, const char** dst, const char* fieldKey);

/*******************************************************************************
 *                                                                             *
 * DO NOT CHANGE THE ORDER OF KEYS BECAUSE WINDOWS BUILDS WILL BE CORRUPTED    *
 *          Visual Studio does not support designated initializers             *
 *                                                                             *
 *******************************************************************************/
/**
 * @struct USDLFieldKeysType
 * @brief Structure that holds definitions for US Driver's License field keys. Use ::USDLFieldKeys global variable to obtain required constants.
 */
struct USDLFieldKeysType {

    /*==============================================================*/
    /*============== 1. DETERMINING BARCODE VERSION ================*/
    /*==============================================================*/

    /**
     Mandatory on all driver's licenses. All barcodes which are using 3-track magnetic
     stripe encoding used in the interest of smoothing a transition from legacy documents
     shall be designated as "Magnetic". All barcodes which are using compact encoding
     compliant with ISO/IEC 18013-2 shall be designated as "Compact". All barcodes (majority)
     compliant with Mandatory PDF417 Bar Code of the American Association of Motor Vehicle
     Administrators (AAMVA) Card Design Standard from AAMVA DL/ID-2000 standard to DL/ID-2013
     shall be designated as "AAMVA".
     */
    const char* kDocumentType;

    /**
     Mandatory on all driver's licenses.

     AAMVA Version Number: This is a decimal value between 0 and 99 that
     specifies the version level of the PDF417 bar code format. Version "0" and "00"
     is reserved for bar codes printed to the specification of the American Association
     of Motor Vehicle Administrators (AAMVA) prior to the adoption of the AAMVA DL/ID-2000
     standard. All bar codes compliant with the AAMVA DL/ID-2000 standard are designated
     Version "01." All barcodes compliant with AAMVA Card Design Specification version
     1.0, dated 09-2003 shall be designated Version "02." All barcodes compliant with
     AAMVA Card Design Specification version 2.0, dated 03-2005 shall be designated
     Version "03." All barcodes compliant with AAMVA Card Design Standard version 1.0,
     dated 07-2009 shall be designated Version "04." All barcodes compliant with AAMVA
     Card Design Standard version 1.0, dated 07-2010 shall be designated Version "05."
     All barcodes compliant with AAMVA Card Design Standard version 1.0, dated 07- 2011
     shall be designated Version "06". All barcodes compliant with AAMVA Card Design
     Standard version 1.0, dated 06-2012 shall be designated Version "07". All barcodes
     compliant with this current AAMVA standard shall be designated "08". Should a need
     arise requiring major revision to the format, this field provides the means to
     accommodate additional revision.

     If document type is not "AAMVA", this field defines version number of the
     given document type's standard.
     */
    const char* kStandardVersionNumber;

    /*==============================================================*/
    /*==========          2. PERSONAL DATA KEYS          ===========*/
    /*==============================================================*/

    /**
     Mandatory on all AAMVA, Magnetic and Compact barcodes.

     Family name of the cardholder. (Family name is sometimes also called "last name" or "surname.")
     Collect full name for record, print as many characters as possible on portrait side of DL/ID.
     */
    const char* kCustomerFamilyName;

    /**
     Mandatory on all AAMVA, Magnetic and Compact barcodes.

     First name of the cardholder.
     */
    const char* kCustomerFirstName;

    /**
     Mandatory on all AAMVA, Magnetic and Compact barcodes.

     Full name of the individual holding the Driver License or ID.

     The Name field contains up to four portions, separated with the "," delimiter:
     Last Name (required)
     , (required)
     First Name (required)
     , (required if other name portions follow, otherwise optional)
     Middle Name(s) (optional)
     , (required if other name portions follow, otherwise optional)
     Suffix (optional)
     , (optional)

     If indvidual has more than one middle name they are separated with space.
     */
    const char* kCustomerFullName;

    /**
     Mandatory on all AAMVA, Magentic and Compact barcodes.

     Date on which the cardholder was born. (MMDDCCYY format)
     */
    const char* kDateOfBirth;

    /**
     Mandatory on all AAMVA, Magentic barcodes.
     Optional on Compact barcodes.

     Gender of the cardholder. 1 = male, 2 = female.
     */
    const char* kSex;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 barcodes.
     Optional on AAMVA 01, Magnetic and Compact barcodes.

     Color of cardholder's eyes. (ANSI D-20 codes)

     Code   Description
     BLK    Black
     BLU    Blue
     BRO    Brown
     GRY    Gray
     GRN    Green
     HAZ    Hazel
     MAR    Maroon
     PNK    Pink
     DIC    Dichromatic
     UNK    Unknown
     */
    const char* kEyeColor;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.

     On compact barcodes, use kFullAddress.

     Street portion of the cardholder address.
     The place where the registered driver of a vehicle (individual or corporation)
     may be contacted such as a house number, street address etc.
     */
    const char* kAddressStreet;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.

     On compact barcodes, use kFullAddress.

     City portion of the cardholder address.
     */
    const char* kAddressCity;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.

     On compact barcodes, use kFullAddress.

     State portion of the cardholder address.
     */
    const char* kAddressJurisdictionCode;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.

     On compact barcodes, use kFullAddress.

     Postal code portion of the cardholder address in the U.S. and Canada. If the
     trailing portion of the postal code in the U.S. is not known, zeros can be used
     to fill the trailing set of numbers up to nine (9) digits.
     */
    const char* kAddressPostalCode;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.
     Optional on Compact barcodes.

     Full address of the individual holding the Driver License or ID.

     The full address field contains up to four portions, separated with the "," delimiter:
     Street Address (required)
     , (required if other address portions follow, otherwise optional)
     City (optional)
     , (required if other address portions follow, otherwise optional)
     Jurisdiction Code (optional)
     , (required if other address portions follow, otherwise optional)
     ZIP - Postal Code (optional)

     */
    const char* kFullAddress;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes.
     Optional on AAMVA 01 and Magnetic barcodes.

     Height of cardholder, either in Inches or in Centimeters.

     Inches (in): number of inches followed by " in"
     example: 6'1'' = "73 in"

     Centimeters (cm): number of centimeters followed by " cm"
     example: 181 centimeters = "181 cm"
     */
    const char* kHeight;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes.
     Optional on AAMVA 01 and Magnetic barcodes.

     Height of cardholder in Inches.
     Example: 5'9'' = "69".
     */
    const char* kHeightIn;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 Compact barcodes.
     Optional on AAMVA 01 and Magnetic barcodes.

     Height of cardholder in Centimeters.
     Example: 180 Centimeters = "180".
     */
    const char* kHeightCm;

    /**
     Mandatory on AAMVA 04, 05, 06, 07, 08.
     Optional on AAMVA 01, 02, 03, Magnetic and Compcat barcodes.

     Middle name(s) of the cardholder. In the case of multiple middle names they
     shall be separated by space " ".
     */
    const char* kCustomerMiddleName;

    /**
     Optional on all AAMVA, Magnetic and Compact barcodes.

     Bald, black, blonde, brown, gray, red/auburn, sandy, white, unknown. If the issuing
     jurisdiction wishes to abbreviate colors, the three-character codes provided in ANSI D20 must be
     used.

     Code   Description
     BAL    Bald
     BLK    Black
     BLN    Blond
     BRO    Brown
     GRY    Grey
     RED    Red/Auburn
     SDY    Sandy
     WHI    White
     UNK    Unknown
     */
    const char* kHairColor;

    /**
     Mandatory on AAMVA 02 barcodes.
     Optional on AAMVA 01, 03, 04, 05, 06, 07, 08, Magnetic and Compact barcodes.

     Name Suffix (If jurisdiction participates in systems requiring name suffix (PDPS, CDLIS, etc.),
     the suffix must be collected and displayed on the DL/ID and in the MRT).
     - JR (Junior)
     - SR (Senior)
     - 1ST or I (First)
     - 2ND or II (Second)
     - 3RD or III (Third)
     - 4TH or IV (Fourth)
     - 5TH or V (Fifth)
     - 6TH or VI (Sixth)
     - 7TH or VII (Seventh)
     - 8TH or VIII (Eighth)
     - 9TH or IX (Ninth)
     */
    const char* kNameSuffix;

    /**
     Optional on all AAMVA and Compact barcodes.

     Other name by which cardholder is known. ALTERNATIVE NAME(S) of the individual
     holding the Driver License or ID.

     The Name field contains up to four portions, separated with the "," delimiter:
     AKA Last Name (required)
     , (required)
     AKA First Name (required)
     , (required if other name portions follow, otherwise optional)
     AKA Middle Name(s) (optional)
     , (required if other name portions follow, otherwise optional)
     AKA Suffix (optional)
     , (optional)

     If indvidual has more than one AKA middle name they are separated with space.
     */
    const char* kAKAFullName;

    /**
     Optional on all AAMVA and Compact barcodes.

     Other family name by which cardholder is known.
     */
    const char* kAKAFamilyName;

    /**
     Optional on all AAMVA and Compact barcodes.

     Other given name by which cardholder is known
     */
    const char* kAKAGivenName;

    /**
     Optional on all AAMVA and Compact barcodes.

     Other suffix by which cardholder is known.

     The Suffix Code Portion, if submitted, can contain only the Suffix Codes shown in the following table:

     Suffix     Meaning or Synonym
     JR         Junior
     SR         Senior or Esquire 1ST First
     2ND        Second
     3RD        Third
     4TH        Fourth
     5TH        Fifth
     6TH        Sixth
     7TH        Seventh
     8TH        Eighth
     9TH        Ninth
     */
    const char* kAKASuffixName;

    /**
     Mandatory on AAMVA 02 barcodes.
     Optional on AAMVA 01, 03, 04, 05, 06, 07, 08, Magnetic and Compact barcodes.

     Indicates the approximate weight range of the cardholder:
     0 = up to 31 kg (up to 70 lbs)
     1 = 32 – 45 kg (71 – 100 lbs)
     2 = 46 - 59 kg (101 – 130 lbs)
     3 = 60 - 70 kg (131 – 160 lbs)
     4 = 71 - 86 kg (161 – 190 lbs)
     5 = 87 - 100 kg (191 – 220 lbs)
     6 = 101 - 113 kg (221 – 250 lbs)
     7 = 114 - 127 kg (251 – 280 lbs)
     8 = 128 – 145 kg (281 – 320 lbs)
     9 = 146+ kg (321+ lbs)
     */
    const char* kWeightRange;

    /**
     Mandatory on AAMVA 02 barcodes.
     Optional on AAMVA 01, 03, 04, 05, 06, 07, 08, Magnetic and Compact barcodes.

     Cardholder weight in pounds Example: 185 lb = "185"
     */
    const char* kWeightPounds;

    /**
     Mandatory on AAMVA 02 barcodes.
     Optional on AAMVA 01, 03, 04, 05, 06, 07, 08, Magnetic and Compact barcodes.

     Cardholder weight in kilograms Example: 84 kg = "084"
     */
    const char* kWeightKilograms;

    /**
     Mandatory on all AAMVA and Compact barcodes

     The number assigned or calculated by the issuing authority.
     */
    const char* kCustomerIdNumber;

    /**
     Mandatory on AAMVA 04, 05, 06, 07, 08 barcodes.
     Optional on Compact barcodes.

     A code that indicates whether a field has been truncated (T), has not been
     truncated (N), or – unknown whether truncated (U).
     */
    const char* kFamilyNameTruncation;

    /**
     Mandatory on AAMVA 04, 05, 06, 07, 08 barcodes.
     Optional on Compact barcodes.

     A code that indicates whether a field has been truncated (T), has not been
     truncated (N), or – unknown whether truncated (U).
     */
    const char* kFirstNameTruncation;

    /**
     Mandatory on AAMVA 04, 05, 06, 07, 08

     A code that indicates whether a field has been truncated (T), has not been
     truncated (N), or – unknown whether truncated (U).
     */
    const char* kMiddleNameTruncation;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     Country and municipality and/or state/province
     */
    const char* kPlaceOfBirth;

    /**
     Optional on all AAMVA barcodes

     On Compact barcodes, use kFullAddress

     Second line of street portion of the cardholder address.
     */
    const char* kAddressStreet2;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     Codes for race or ethnicity of the cardholder, as defined in ANSI D20.

     Race:
     Code   Description
     AI     Alaskan or American Indian (Having Origins in Any of The Original Peoples of
            North America, and Maintaining Cultural Identification Through Tribal
            Affiliation of Community Recognition)
     AP     Asian or Pacific Islander (Having Origins in Any of the Original Peoples of
            the Far East, Southeast Asia, or Pacific Islands. This Includes China, India,
            Japan, Korea, the Philippines Islands, and Samoa)
     BK     Black (Having Origins in Any of the Black Racial Groups of Africa)
     W      White (Having Origins in Any of The Original Peoples of Europe, North Africa,
            or the Middle East)

     Ethnicity:
     Code   Description
     H      Hispanic Origin (A Person of Mexican, Puerto Rican, Cuban, Central or South
            American or Other Spanish Culture or Origin, Regardless of Race)
     O      Not of Hispanic Origin (Any Person Other Than Hispanic)
     U      Unknown

     */
    const char* kRaceEthnicity;

    /**
     Optional on AAMVA 01

     PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.
     */
    const char* kNamePrefix;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes.

     Country in which DL/ID is issued. U.S. = USA, Canada = CAN.
     */
    const char* kCountryIdentification;

    /**
     Optional on AAMVA version 01.

     Driver Residence Street Address 1.
     */
    const char* kResidenceStreetAddress;

    /**
     Optional on AAMVA version 01.

     Driver Residence Street Address 2.
     */
    const char* kResidenceStreetAddress2;

    /**
     Optional on AAMVA version 01.

     Driver Residence City
     */
    const char* kResidenceCity;

    /**
     Optional on AAMVA version 01.

     Driver Residence Jurisdiction Code.
     */
    const char* kResidenceJurisdictionCode;

    /**
     Optional on AAMVA 01 barcodes.

     Driver Residence Postal Code.
     */
    const char* kResidencePostalCode;

    /**
     Optional on AAMVA 01 barcodes.

     Full residence address of the individual holding the Driver License or ID.

     The full address field contains up to four portions, separated with the "," delimiter:
     Residence Street Address (required)
     , (required if other address portions follow, otherwise optional)
     Residence City (optional)
     , (required if other address portions follow, otherwise optional)
     Residence Jurisdiction Code (optional)
     , (required if other address portions follow, otherwise optional)
     Residence ZIP - Residence Postal Code (optional)
     */
    const char* kResidenceFullAddress;

    /**
     Optional on AAMVA 05, 06, 07, 08

     Date on which the cardholder turns 18 years old. (MMDDCCYY format)
     */
    const char* kUnder18;

    /**
     Optional on AAMVA 05, 06, 07, 08

     Date on which the cardholder turns 19 years old. (MMDDCCYY format)
     */
    const char* kUnder19;

    /**
     Optional on AAMVA 05, 06, 07, 08

     Date on which the cardholder turns 21 years old. (MMDDCCYY format)
     */
    const char* kUnder21;

    /**
     Optional on AAMVA version 01.

     The number assigned to an individual by the Social Security Administration.
     */
    const char* kSocialSecurityNumber;

    /**
     Optional on AAMVA version 01.

     Driver "AKA" Social Security Number. FORMAT SAME AS DRIVER SOC SEC NUM. ALTERNATIVE NUMBERS(S) used as SS NUM.
     */
    const char* kAKASocialSecurityNumber;

    /**
     Optional on AAMVA 01

     ALTERNATIVE MIDDLE NAME(s) or INITIALS of the individual holding the Driver License or ID.
     Hyphenated names acceptable, spaces between names acceptable, but no other
     use of special symbols
     */
    const char* kAKAMiddleName;

    /**
     Optional on AAMVA 01

     ALTERNATIVE PREFIX to Driver Name. Freeform as defined by issuing jurisdiction.
     */
    const char* kAKAPrefixName;

    /**
     Optional on AAMVA 01, 06, 07, 08

     Field that indicates that the cardholder is an organ donor = "1".
     */
    const char* kOrganDonor;

    /**
     Optional on AAMVA 07, 08

     Field that indicates that the cardholder is a veteran = "1"
     */
    const char* kVeteran;

    /**
     Optional on AAMVA 01. (MMDDCCYY format)

     ALTERNATIVE DATES(S) given as date of birth.
     */
    const char* kAKADateOfBirth;

    /*==============================================================*/
    /*==========          3. LICENSE DATA KEYS          ============*/
    /*==============================================================*/

    /**
     Mandatory on all AAMVA, Magnetic and Compact barcodes.

     This number uniquely identifies the issuing jurisdiction and can
     be obtained by contacting the ISO Issuing Authority (AAMVA)
     */
    const char* kIssuerIdentificationNumber;

    /**
      Optional on all AAMVA and Magnetic barcodes.

      Name of issuing jurisdiction, for example: Alabama, Alaska ...
      */
    const char* kIssuingJurisdictionName;

    /**
     Mandatory on all AAMVA, Magnetic and Compact barcodes.

     If document is non expiring than "Non expiring" is written in this field.

     Date on which the driving and identification privileges granted by the document are
     no longer valid. (MMDDCCYY format)
     */
    const char* kDocumentExpirationDate;

    /**
     Mandatory on all AAMVA and Compact barcodes.
     Optional on Magnetic barcodes.

     Jurisdiction Version Number: This is a decimal value between 0 and 99 that
     specifies the jurisdiction version level of the PDF417 bar code format.
     Notwithstanding iterations of this standard, jurisdictions implement incremental
     changes to their bar codes, including new jurisdiction-specific data, compression
     algorithms for digitized images, digital signatures, or new truncation
     conventions used for names and addresses. Each change to the bar code format
     within each AAMVA version (above) must be noted, beginning with Jurisdiction
     Version 00.
     */
    const char* kJurisdictionVersionNumber;

    /**
     Mandatory on all AAMVA and Magnetic barcodes.

     Jurisdiction-specific vehicle class / group code, designating the type
     of vehicle the cardholder has privilege to drive.
     */
    const char* kJurisdictionVehicleClass;

    /**
     Mandatory on all AAMVA barcodes.
     Optional on Magnetic barcodes.

     Jurisdiction-specific codes that represent restrictions to driving
     privileges (such as airbrakes, automatic transmission, daylight only, etc.).
     */
    const char* kJurisdictionRestrictionCodes;

    /**
     Mandatory on all AAMVA barcodes.
     Optional on Magnetic barcodes.

     Jurisdiction-specific codes that represent additional privileges
     granted to the cardholder beyond the vehicle class (such as transportation of
     passengers, hazardous materials, operation of motorcycles, etc.).
     */
    const char* kJurisdictionEndorsementCodes;

    /**
     Mandatory on all AAMVA and Compact barcodes.

     Date on which the document was issued. (MMDDCCYY format)
     */
    const char* kDocumentIssueDate;

    /**
     Mandatory on AAMVA versions 02 and 03.

     Federally established codes for vehicle categories, endorsements, and restrictions
     that are generally applicable to commercial motor vehicles. If the vehicle is not a
     commercial vehicle, "NONE" is to be entered.
     */
    const char* kFederalCommercialVehicleCodes;

    /**
     Optional on all AAMVA barcodes.
     Mandatory on Compact barcodes.

     Jurisdictions may define a subfile to contain jurisdiction-specific information.
     These subfiles are designated with the first character of “Z” and the second
     character is the first letter of the jurisdiction's name. For example, "ZC" would
     be the designator for a California or Colorado jurisdiction-defined subfile; "ZQ"
     would be the designator for a Quebec jurisdiction-defined subfile. In the case of
     a jurisdiction-defined subfile that has a first letter that could be more than
     one jurisdiction (e.g. California, Colorado, Connecticut) then other data, like
     the IIN or address, must be examined to determine the jurisdiction.
     */
    const char* kIssuingJurisdiction;

    /**
     Optional on all AAMVA barcodes.
     Mandatory on Compact barcodes.

     Standard vehicle classification code(s) for cardholder. This data element is a
     placeholder for future efforts to standardize vehicle classifications.
     */
    const char* kStandardVehicleClassification;


    /**
     Optional on all AAMVA barcodes.

     Standard endorsement code(s) for cardholder. See codes in D20. This data element is a
     placeholder for future efforts to standardize endorsement codes.

     Code   Description
     H      Hazardous Material - This endorsement is required for the operation of any vehicle
            transporting hazardous materials requiring placarding, as defined by U.S.
            Department of Transportation regulations.
     L      Motorcycles – Including Mopeds/Motorized Bicycles.
     N      Tank - This endorsement is required for the operation of any vehicle transporting,
            as its primary cargo, any liquid or gaseous material within a tank attached to the vehicle.
     O      Other Jurisdiction Specific Endorsement(s) - This code indicates one or more
            additional jurisdiction assigned endorsements.
     P      Passenger - This endorsement is required for the operation of any vehicle used for
            transportation of sixteen or more occupants, including the driver.
     S      School Bus - This endorsement is required for the operation of a school bus. School bus means a
            CMV used to transport pre-primary, primary, or secondary school students from home to school,
            from school to home, or to and from school sponsored events. School bus does not include a
            bus used as common carrier (49 CRF 383.5).
     T      Doubles/Triples - This endorsement is required for the operation of any vehicle that would be
            referred to as a double or triple.
     X      Combined Tank/HAZ-MAT - This endorsement may be issued to any driver who qualifies for
            both the N and H endorsements.
     */
    const char* kStandardEndorsementCode;

    /**
     Optional on all AAMVA barcodes

     Standard restriction code(s) for cardholder. See codes in D20. This data element is a placeholder
     for future efforts to standardize restriction codes.

     Code   Description
     B      Corrective Lenses
     C      Mechanical Devices (Special Brakes, Hand Controls, or Other Adaptive Devices)
     D      Prosthetic Aid
     E      Automatic Transmission
     F      Outside Mirror
     G      Limit to Daylight Only
     H      Limit to Employment
     I      Limited Other
     J      Other
     K      CDL Intrastate Only
     L      Vehicles without air brakes
     M      Except Class A bus
     N      Except Class A and Class B bus
     O      Except Tractor-Trailer
     V      Medical Variance Documentation Required
     W      Farm Waiver
     */
    const char* kStandardRestrictionCode;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     Text that explains the jurisdiction-specific code(s) for classifications
     of vehicles cardholder is authorized to drive.
     */
    const char* kJurisdictionVehicleClassificationDescription;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     Text that explains the jurisdiction-specific code(s) that indicates additional
     driving privileges granted to the cardholder beyond the vehicle class.
     */
    const char* kJurisdictionEndorsmentCodeDescription;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     Text describing the jurisdiction-specific restriction code(s) that curtail driving privileges.
     */
    const char* kJurisdictionRestrictionCodeDescription;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08

     A string of letters and/or numbers that is affixed to the raw materials (card stock,
     laminate, etc.) used in producing driver licenses and ID cards. (DHS recommended field)
     */
    const char* kInventoryControlNumber;

    /**
     Optional on AAMVA 04, 05, 06, 07, 08 and Compact barcodes

     DHS required field that indicates date of the most recent version change or
     modification to the visible format of the DL/ID (MMDDCCYY format)
     */
    const char* kCardRevisionDate;

    /**
     Mandatory on AAMVA 02, 03, 04, 05, 06, 07, 08 and Magnetic barcodes.
     Optional and Compact barcodes

     Number must uniquely identify a particular document issued to that customer
     from others that may have been issued in the past. This number may serve multiple
     purposes of document discrimination, audit information number, and/or inventory control.
     */
    const char* kDocumentDiscriminator;

    /**
     Optional on AAMVA 04, 05, 06, 07, 08 and Compact barcodes

     DHS required field that indicates that the cardholder has temporary lawful status = "1".
     */
    const char* kLimitedDurationDocument;

    /**
     Optional on AAMVA 02, 03, 04, 05, 06, 07, 08 and Compact barcodes

     A string of letters and/or numbers that identifies when, where, and by whom a driver
     license/ID card was made. If audit information is not used on the card or the MRT, it
     must be included in the driver record.
     */
    const char* kAuditInformation;

    /**
     Optional on AAMVA 04, 05, 06, 07, 08 and Compact barcodes

     DHS required field that indicates compliance: "M" = materially compliant;
     "F" = fully compliant; and, "N" = non-compliant.
     */
    const char* kComplianceType;

    /**
     Optional on AAMVA version 01.

     Issue Timestamp. A string used by some jurisdictions to validate the document against their data base.
     */
    const char* kIssueTimestamp;

    /**
     Optional on AAMVA version 01.

     Driver Permit Expiration Date. MMDDCCYY format. Date permit expires.
     */
    const char* kPermitExpirationDate;

    /**
     Optional on AAMVA version 01.

     Type of permit.
     */
    const char* kPermitIdentifier;

    /**
     Optional on AAMVA version 01.

     Driver Permit Issue Date. MMDDCCYY format. Date permit was issued.
     */
    const char* kPermitIssueDate;

    /**
     Optional on AAMVA version 01.

     Number of duplicate cards issued for a license or ID if any.
     */
    const char* kNumberOfDuplicates;

    /**
     Optional on AAMVA 04, 05, 06, 07, 08 and Compact barcodes

     Date on which the hazardous material endorsement granted by the document is
     no longer valid. (MMDDCCYY format)
     */
    const char* kHAZMATExpirationDate;

    /**
     Optional on AAMVA version 01.

     Medical Indicator/Codes.
     STATE SPECIFIC. Freeform; Standard "TBD"
     */
    const char* kMedicalIndicator;

    /**
     Optional on AAMVA version 01.

     Non-Resident Indicator. "Y". Used by some jurisdictions to indicate holder of the document is a non-resident.
     */
    const char* kNonResident;

    /**
     Optional on AAMVA version 01.

     A number or alphanumeric string used by some jurisdictions to identify a "customer" across multiple data bases.
     */
    const char* kUniqueCustomerId;

    /**
     Optional on compact barcodes.

     Document discriminator.
     */
    const char* kDataDiscriminator;

    /**
     Optional on Magnetic barcodes.

     Month on which the driving and identification privileges granted by the document are
     no longer valid. (MMYY format)
     */
    const char* kDocumentExpirationMonth;

    /**
     Optional on Magnetic barcodes.

     Field that indicates that the driving and identification privileges granted by the
     document are nonexpiring = "1".
     */
    const char* kDocumentNonexpiring;

    /**
      Optional on Magnetic barcodes.

      Security version beeing used.
    */
    const char* kSecurityVersion;
};

/**
 * @var USDLFieldKeys
 * Holder for field keys for US Driver's License result
 */
PP_API extern const struct USDLFieldKeysType USDLFieldKeys;



#ifdef __cplusplus
}
#endif

#endif
